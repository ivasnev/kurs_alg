# id 60721655
# -- ПРИНЦИП РАБОТЫ --
# Я реализовал калькулятор обратной польской записи.
# Все числа из записи добавляются в стек numbers.
# В основной программе считывается польская запись
# далее мы проходим по ней пытаясь преобразовть входные данные к числу
# если получилоси добавляем их в numbers
# иначе проверяем хватает ли нам чисел для вычисление и проводим вычисления
# выводим голову стека(результат подсчётов)
#
#
# -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
# Для реализации стека выбрана двунаправленная очередь,
# Добавление в стек стоит O(1), потому что добавление в очередь стоит O(1).
# Извлечение из очереди стоит O(1)
#
# Оценим основной алгоритм:
# n в данном случае кол. чисел+операндов
# Считываем данные и делим их по пробелу за О(n)
# Проходим по входным данным за О(n) при этом добавляя в стек за О(1)
# Если на вход призодит операнд производим вычисления за О(1) и добавляем
# их в стек за О(1)
# Общая сложность алгоритма по времени О(n)
#
# -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
# Если польская запись содержит n элементов, то стек numbers содержит n1 элементов
#
# Стек и список, содержащие k элементов, занимают каждый по O(k) памяти.
# Поэтому моя реализация решения польской записи
# будет потреблять O(n1) + O(n) = O(n) памяти, так как n1 <= n


from collections import deque

numbers = deque()
inp = input().split()
for i in inp:
    try:
        numbers.append(int(i))
    except ValueError:
        if len(numbers) >= 2:
            b = numbers.pop()
            a = numbers.pop()
            if i == "/":
                numbers.append(a // b)
            elif i == "*":
                numbers.append(a * b)
            elif i == "+":
                numbers.append(a + b)
            elif i == "-":
                numbers.append(a - b)
print(numbers.pop())
